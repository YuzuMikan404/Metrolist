name: Monitor Upstream Release and Build

on:
  workflow_dispatch:        # 手動実行用
  schedule:
    - cron: '0 * * * *'     # 1時間ごとにチェック

permissions:
  contents: write           # リリースの作成・削除に必要

jobs:
  check_and_build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 1. 更新チェック & (手動時は) 旧リリース削除
      - name: Check and Cleanup
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 本家の最新タグを取得
          UPSTREAM_TAG=$(gh api repos/mostafaalagamy/Metrolist/releases/latest --jq .tag_name)
          echo "Target version: $UPSTREAM_TAG"
          
          # --- 分岐処理 ---
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # 【手動実行の場合】強制的に掃除してビルドする
            echo "Manual trigger detected. Cleaning up old release for $UPSTREAM_TAG..."
            
            # 既存のリリースとタグを削除 (エラーが出ても無視して進む || true)
            gh release delete "$UPSTREAM_TAG" --yes --cleanup-tag || true
            git push --delete origin "$UPSTREAM_TAG" || true
            
            echo "Cleanup complete. Force starting build."
            echo "trigger=true" >> $GITHUB_OUTPUT
            echo "tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT
          
          else
            # 【定期実行の場合】既にあったら何もしない
            if git rev-parse "$UPSTREAM_TAG" >/dev/null 2>&1; then
              echo "Tag $UPSTREAM_TAG already exists. Skipping."
              echo "trigger=false" >> $GITHUB_OUTPUT
            else
              echo "New version found. Starting build."
              echo "trigger=true" >> $GITHUB_OUTPUT
              echo "tag=$UPSTREAM_TAG" >> $GITHUB_OUTPUT
            fi
          fi

      # 2. ソース取得 & アイコン準備
      - name: Fetch Source
        if: steps.check.outputs.trigger == 'true'
        run: |
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          cp icon.png /tmp/icon.png || echo "No icon found"
          git remote add upstream https://github.com/mostafaalagamy/Metrolist.git
          git fetch upstream --tags
          git checkout -b build-${{ steps.check.outputs.tag }} refs/tags/${{ steps.check.outputs.tag }}
          if [ -f /tmp/icon.png ]; then mv /tmp/icon.png icon.png; fi

      # 3. 環境構築
      - if: steps.check.outputs.trigger == 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      - if: steps.check.outputs.trigger == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - if: steps.check.outputs.trigger == 'true'
        uses: gradle/actions/setup-gradle@v4

      # 4. アイコン処理 (色吸い出し & 前景生成)
      - name: Process Icon
        if: steps.check.outputs.trigger == 'true'
        run: |
          if [ -f icon.png ]; then
            pip install Pillow
            python -c "
            from PIL import Image, ImageOps
            
            try:
                img = Image.open('icon.png').convert('RGBA')
                # 背景色抽出
                pixel = img.resize((1, 1)).getpixel((0, 0))
                bg_hex = '#000000' if pixel[3] == 0 else '#{:02x}{:02x}{:02x}'.format(*pixel[:3])
                
                with open('bg_color.txt', 'w') as f:
                    f.write(bg_hex)
                print(f'Background: {bg_hex}')

                # アダプティブ用前景生成 (65%サイズ)
                size = 1080
                target = int(size * 0.65)
                canvas = Image.new('RGBA', (size, size), (0, 0, 0, 0))
                resized = ImageOps.fit(img, (target, target), centering=(0.5, 0.5))
                offset = (size - target) // 2
                canvas.paste(resized, (offset, offset), resized)
                canvas.save('icon_foreground.png')
                
            except Exception as e:
                print(f'Error: {e}')
            "
          else
            echo "#000000" > bg_color.txt
          fi

      # 5. ファイル書き換え (Gradle注入 & XML生成)
      - name: Apply Modifications
        if: steps.check.outputs.trigger == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // A. アダプティブアイコン設定
            const bgColor = fs.existsSync('bg_color.txt') ? fs.readFileSync('bg_color.txt', 'utf8').trim() : '#000000';
            const resPath = 'app/src/main/res';
            
            if (fs.existsSync(resPath) && fs.existsSync('icon_foreground.png')) {
                const anydpi = path.join(resPath, 'mipmap-anydpi-v26');
                fs.mkdirSync(anydpi, { recursive: true });
                
                const xml = \`<?xml version="1.0" encoding="utf-8"?>
            <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
                <background android:drawable="@color/ic_launcher_background" />
                <foreground android:drawable="@mipmap/ic_launcher_foreground" />
            </adaptive-icon>\`;
                
                fs.writeFileSync(path.join(anydpi, 'ic_launcher.xml'), xml);
                fs.writeFileSync(path.join(anydpi, 'ic_launcher_round.xml'), xml);

                fs.readdirSync(resPath).filter(n => n.startsWith('mipmap-') && !n.includes('anydpi')).forEach(dir => {
                    const p = path.join(resPath, dir);
                    // 古いファイル削除
                    fs.readdirSync(p).filter(f => f.startsWith('ic_launcher')).forEach(f => fs.unlinkSync(path.join(p, f)));
                    // 新しい前景画像
                    fs.copyFileSync('icon_foreground.png', path.join(p, 'ic_launcher_foreground.png'));
                    // Legacy用
                    if(fs.existsSync('icon.png')) {
                        fs.copyFileSync('icon.png', path.join(p, 'ic_launcher.png'));
                        fs.copyFileSync('icon.png', path.join(p, 'ic_launcher_round.png'));
                    }
                });
            }

            // B. ダミーJSON
            fs.writeFileSync('app/google-services.json', JSON.stringify({ "project_info": { "project_number": "0", "project_id": "d" }, "client": [{ "client_info": { "mobilesdk_app_id": "1:0:a:0", "android_client_info": { "package_name": "com.metrolist.clone" } }, "api_key": [{ "current_key": "d" }] }] }));

            // C. Gradle & Manifest
            function walk(dir) {
                fs.readdirSync(dir).forEach(f => {
                    let p = path.join(dir, f);
                    if (f === '.git') return;
                    fs.statSync(p).isDirectory() ? walk(p) : process(p);
                });
            }

            function process(f) {
                // build.gradle.kts
                if (f.endsWith('build.gradle.kts')) {
                    let c = fs.readFileSync(f, 'utf8');
                    c = c.replace(/applicationId\s*=\s*"[^"]*"/g, 'applicationId = "com.metrolist.clone"');
                    c = c.replace(/(.*alias\(libs\.plugins\.google\.services\).*)/g, '// $1');
                    c = c.replace(/(.*id\("com\.google\.gms\.google-services"\).*)/g, '// $1');
                    // 値の注入 (Metrolist Neo)
                    if (c.includes('defaultConfig {')) {
                         c = c.replace('defaultConfig {', \`defaultConfig { 
                         resValue("string", "app_name", "Metrolist Neo")
                         resValue("color", "ic_launcher_background", "\${bgColor}")\`);
                    }
                    fs.writeFileSync(f, c, 'utf8');
                }
                // AndroidManifest.xml
                if (f.endsWith('AndroidManifest.xml')) {
                     let c = fs.readFileSync(f, 'utf8');
                     c = c.replace(/android:label="[^"]*"/g, 'android:label="@string/app_name"');
                     c = c.replace(/android:icon="[^"]*"/g, 'android:icon="@mipmap/ic_launcher"');
                     if (c.includes('android:roundIcon=')) {
                         c = c.replace(/android:roundIcon="[^"]*"/g, 'android:roundIcon="@mipmap/ic_launcher_round"');
                     } else {
                         c = c.replace('<application', '<application android:roundIcon="@mipmap/ic_launcher_round"');
                     }
                     fs.writeFileSync(f, c, 'utf8');
                }
            }
            walk('.');

      - name: Grant permissions
        if: steps.check.outputs.trigger == 'true'
        run: chmod +x gradlew

      # 6. ビルド
      - name: Build APK
        if: steps.check.outputs.trigger == 'true'
        run: ./gradlew assembleRelease --no-configuration-cache -x lint -x test
        env:
          GITHUB_EVENT_NAME: pull_request
          LASTFM_API_KEY: "dummy"
          LASTFM_SECRET: "dummy"

      # 7. 回収
      - name: Collect APKs
        if: steps.check.outputs.trigger == 'true'
        run: |
          mkdir -p output_apks
          find app/build/outputs/apk -name "*.apk" -type f -exec cp {} output_apks/ \;

      # 8. 署名
      - name: Sign APK
        if: steps.check.outputs.trigger == 'true'
        uses: ilharp/sign-android-release@v1
        with:
          releaseDir: output_apks
          signingKey: ${{ secrets.SIGNING_KEY }}
          keyAlias: ${{ secrets.ALIAS }}
          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}
          keyPassword: ${{ secrets.KEY_PASSWORD }}
          buildToolsVersion: "34.0.0"

      # 9. リリース (シンプルタイトル・旧タグ削除後の新規作成)
      - name: Create Release
        if: steps.check.outputs.trigger == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.check.outputs.tag }}
          name: ${{ steps.check.outputs.tag }} # バージョン番号のみ
          body: |
            Original: https://github.com/mostafaalagamy/Metrolist/releases/tag/${{ steps.check.outputs.tag }}
          files: output_apks/*-signed.apk
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
